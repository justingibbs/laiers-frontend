# Job Matching App - Cursor AI Rules

## Project Context
Building a job matching MVP where Talent and Companies chat with AI agents. FastAPI application with custom authentication and UI, powered by Google ADK for agent functionality.

## Required Tech Stack (DO NOT SUGGEST ALTERNATIVES)
- Python with UV dependency management
- FastAPI backend with Jinja2 templates
- HTMX for dynamic frontend interactions
- Google ADK for agent orchestration and LLM backend
- Vertex AI (Gemini) via ADK
- Firebase Authentication
- Firestore for all data storage
- Cloud Run for deployment
- Google Cloud Storage via ADK Artifacts for files

## Architecture Constraints
- Main FastAPI app with ADK mounted as sub-application
- No microservices, no complex session management
- Use Firestore for everything (no SQLite, no other databases)
- ADK Artifacts for file handling (no custom upload logic)
- Environment-based configuration only
- Jinja2 templates for HTML rendering
- HTMX for dynamic interactions (no complex JavaScript)

## Project Structure
```
laiers/
â”œâ”€â”€ main.py                 # Main FastAPI app with ADK integration
â”œâ”€â”€ job_matching_agent/     # ADK agent directory (REQUIRED structure)
â”‚   â”œâ”€â”€ __init__.py        # Must contain: from . import agent
â”‚   â””â”€â”€ agent.py           # Must contain: root_agent = Agent(...)
â”œâ”€â”€ pyproject.toml         # UV project configuration & dependencies
â”œâ”€â”€ uv.lock               # UV lockfile (auto-generated)
â”œâ”€â”€ .env                   # Environment variables (local dev)
â”œâ”€â”€ .env.example          # Template for environment variables
â”œâ”€â”€ .gitignore            # Git ignore file
â”œâ”€â”€ README.md             # Project documentation
â”œâ”€â”€ templates/            # Jinja2 template files
â”‚   â”œâ”€â”€ base.html         # Base template with common elements
â”‚   â”œâ”€â”€ landing.html      # Landing page
â”‚   â”œâ”€â”€ login.html        # Login page
â”‚   â”œâ”€â”€ register.html     # Registration page
â”‚   â”œâ”€â”€ dashboard.html    # Main dashboard with profile + chat
â”‚   â”œâ”€â”€ company.html      # Company portal with opportunities list
â”‚   â”œâ”€â”€ opportunities_list.html  # Browse all opportunities (talent users)
â”‚   â”œâ”€â”€ create_opportunity.html  # AI-guided opportunity creation
â”‚   â”œâ”€â”€ opportunity_detail.html  # Job details + application form
â”‚   â””â”€â”€ components/       # Reusable template components
â”‚       â”œâ”€â”€ chat_message.html      # Chat message component
â”‚       â”œâ”€â”€ chat_error.html        # Chat error component
â”‚       â”œâ”€â”€ opportunity_card.html  # Opportunity display card
â”‚       â””â”€â”€ survey_form.html       # Application survey form
â”œâ”€â”€ static/               # Static assets
â”‚   â”œâ”€â”€ css/
â”‚   â”‚   â””â”€â”€ styles.css    # Main stylesheet
â”‚   â””â”€â”€ images/           # Static images
â”œâ”€â”€ config/
â”‚   â”œâ”€â”€ firebase-credentials.json     # Firebase service account key
â”‚   â””â”€â”€ firebase-web-config.json      # Firebase web app config
â”œâ”€â”€ utils/                # Utility modules (keep minimal)
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ firestore.py      # Firestore helpers + opportunity management
â”‚   â”œâ”€â”€ auth.py           # Firebase authentication helpers
â”‚   â”œâ”€â”€ middleware.py     # Maintenance mode middleware
â”‚   â””â”€â”€ models.py         # Pydantic models
â”œâ”€â”€ deployment/           # Cloud Run deployment system
â”‚   â”œâ”€â”€ deploy.sh         # Full-featured deployment script
â”‚   â”œâ”€â”€ quick-deploy.sh   # Quick deployment commands
â”‚   â”œâ”€â”€ README.md         # Comprehensive deployment guide
â”‚   â””â”€â”€ cloudbuild.yaml  # Cloud Build configuration
â”œâ”€â”€ Dockerfile            # Container configuration for Cloud Run (uses UV)
â”œâ”€â”€ .dockerignore        # Files excluded from container build
â””â”€â”€ run.py               # Entry point for Cloud Run deployment
```

## Code Patterns to Follow

### ADK + FastAPI Integration Pattern
```python
import os
from fastapi import FastAPI, Request, Depends
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates
from fastapi.responses import HTMLResponse, RedirectResponse
from google.adk.cli.fast_api import get_fast_api_app

# Create main FastAPI app for custom routes
app = FastAPI(title="Job Matching App")

# Initialize templates and static files
templates = Jinja2Templates(directory="templates")
app.mount("/static", StaticFiles(directory="static"), name="static")

# Get ADK app and mount it under /adk path
AGENT_DIR = os.path.dirname(os.path.abspath(__file__))
adk_app = get_fast_api_app(
    agents_dir=AGENT_DIR,
    allow_origins=["*"] if ENVIRONMENT == "development" else [],
    web=True,  # Enables dev UI at /adk/dev-ui/
)

# Mount ADK app under /adk prefix
app.mount("/adk", adk_app)

# Your custom routes
@app.get("/", response_class=HTMLResponse)
async def landing_page(request: Request, user = Depends(optional_auth)):
    """Landing page - redirect to dashboard if logged in"""
    if user:
        return RedirectResponse(url="/dashboard", status_code=302)
    return templates.TemplateResponse("landing.html", {"request": request})

@app.get("/dashboard", response_class=HTMLResponse)
async def dashboard(request: Request, user = Depends(require_auth)):
    """Dashboard with profile + chat interface"""
    user_profile = await firestore_service.get_user_profile(user['uid'])
    return templates.TemplateResponse("dashboard.html", {
        "request": request,
        "user": user,
        "user_profile": user_profile
    })

@app.post("/api/chat")
async def chat_with_agent(
    request: Request,
    message: str = Form(...),
    user = Depends(require_auth)
):
    """Chat with ADK agent via HTMX"""
    # Use ADK's HTTP API internally
    payload = {
        "appName": "job_matching_agent",
        "userId": user["uid"],
        "sessionId": f"session_{user['uid']}",
        "newMessage": {"role": "user", "parts": [{"text": message}]},
        "streaming": False
    }
    
    async with httpx.AsyncClient() as client:
        response = await client.post("http://localhost:8000/adk/run", json=payload)
        agent_response = response.json()
    
    # Return HTMX partial
    return templates.TemplateResponse("components/chat_message.html", {
        "request": request,
        "user_message": message,
        "agent_response": agent_response[0]["content"]["parts"][0]["text"],
        "timestamp": datetime.now()
    })
```

### ADK Agent Structure (REQUIRED)
```python
# job_matching_agent/__init__.py
from . import agent

# job_matching_agent/agent.py
from google.adk.agents import Agent

# This MUST be named 'root_agent' for ADK discovery
root_agent = Agent(
    name="job_matching_agent",
    model="gemini-2.0-flash-exp",
    instruction="""You are a job matching assistant.
    
    Context: You will receive user information including their user_type ('talent' or 'company').
    
    For 'talent' users:
    - Help with resume review, job search, interview prep, career advice
    
    For 'company' users:  
    - Help with job postings, candidate screening, hiring strategies
    
    Always adapt your responses based on the user_type in the context."""
)
```

### Dashboard Template Pattern (Two-Panel Layout)
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard - Job Matching App</title>
    <script src="https://unpkg.com/htmx.org@1.9.10"></script>
    <style>
        /* Two-column layout */
        .content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            max-width: 1200px;
            margin: 2rem auto;
        }
        
        @media (max-width: 768px) {
            .content { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <div class="dashboard-header">
        <div class="user-info">
            <h2>Welcome, {{ user_profile.profile.name or user.email }}</h2>
            <span class="user-type">{{ user_profile.user_type | title }}</span>
        </div>
        <button 
            class="sign-out"
            hx-post="/api/logout"
            hx-confirm="Are you sure you want to sign out?"
        >Sign Out</button>
    </div>

    <div class="content">
        <!-- Profile Panel -->
        <div class="profile-card">
            <h2>Profile Information</h2>
            <!-- Profile data display -->
        </div>

        <!-- Chat Panel -->
        <div class="chat-card">
            <h2>ðŸ¤– AI Job Assistant</h2>
            
            <div id="chat-messages" class="chat-messages">
                <div class="welcome-message">
                    {% if user_profile.user_type == 'talent' %}
                        I'm here to help with job searching, resumes, and career advice.
                    {% else %}
                        I'm here to help with job postings and hiring strategies.
                    {% endif %}
                </div>
            </div>
            
            <form 
                class="chat-form"
                hx-post="/api/chat" 
                hx-target="#chat-messages" 
                hx-swap="beforeend"
                hx-trigger="submit"
            >
                <input 
                    type="text" 
                    name="message" 
                    placeholder="Ask me anything about jobs and careers..." 
                    required 
                    autocomplete="off"
                >
                <button type="submit">Send</button>
            </form>
        </div>
    </div>
</body>
</html>
```

### Chat Message Component Pattern
```html
<!-- templates/components/chat_message.html -->
<div class="message-pair">
    <!-- User message -->
    <div class="user-message">
        <div class="message-content">{{ user_message }}</div>
        <div class="message-timestamp">{{ timestamp.strftime('%H:%M') }}</div>
    </div>
    
    <!-- Agent response -->
    <div class="agent-message">
        <div class="message-avatar">ðŸ¤–</div>
        <div class="message-content">{{ agent_response }}</div>
        <div class="message-timestamp">{{ timestamp.strftime('%H:%M') }}</div>
    </div>
</div>
```

### Firebase Auth Pattern
```python
# utils/auth.py (simplified from original .cursorrules)
from fastapi import Depends, HTTPException, Cookie
from firebase_admin import auth

async def get_current_user(session_token: str = Cookie(None)):
    if not session_token:
        return None
    try:
        decoded_token = auth.verify_session_cookie(session_token, check_revoked=True)
        return decoded_token
    except Exception:
        return None

async def require_auth(session_token: str = Cookie(None)):
    user = await get_current_user(session_token)
    if not user:
        raise HTTPException(status_code=401, detail="Authentication required")
    return user

async def optional_auth(session_token: str = Cookie(None)):
    return await get_current_user(session_token)
```

### Firestore Helper Pattern
```python
# utils/firestore.py
from google.cloud import firestore
import os

class FirestoreService:
    def __init__(self):
        self.db = firestore.Client(project=os.getenv("GOOGLE_CLOUD_PROJECT"))
    
    async def create_user_profile(self, uid: str, email: str, user_type: str) -> bool:
        try:
            doc_ref = self.db.collection("users").document(uid)
            doc_ref.set({
                "email": email,
                "user_type": user_type,
                "created_at": firestore.SERVER_TIMESTAMP,
                "profile": {}
            })
            return True
        except Exception as e:
            logger.error(f"Error creating user profile: {e}")
            return False
    
    async def get_user_profile(self, uid: str) -> dict | None:
        try:
            doc = self.db.collection("users").document(uid).get()
            return doc.to_dict() if doc.exists else None
        except Exception as e:
            logger.error(f"Error getting user profile: {e}")
            return None

    # NEW: Opportunity Management Methods
    async def create_opportunity(self, opportunity_data: dict) -> str | None:
        try:
            doc_ref = self.db.collection("opportunities").add({
                **opportunity_data,
                "created_at": firestore.SERVER_TIMESTAMP,
                "status": "active"
            })
            return doc_ref[1].id
        except Exception as e:
            logger.error(f"Error creating opportunity: {e}")
            return None
    
    async def get_all_opportunities(self) -> list:
        try:
            query = self.db.collection('opportunities').where('status', '==', 'active')
            docs = query.stream()
            opportunities = []
            for doc in docs:
                opportunity_data = doc.to_dict()
                opportunity_data['id'] = doc.id
                opportunities.append(opportunity_data)
            opportunities.sort(key=lambda x: x.get('created_at'), reverse=True)
            return opportunities
        except Exception as e:
            logger.error(f"Error getting all opportunities: {e}")
            return []
    
    async def submit_application(self, application_data: dict) -> bool:
        try:
            self.db.collection("applications").add({
                **application_data,
                "applied_at": firestore.SERVER_TIMESTAMP
            })
            return True
        except Exception as e:
            logger.error(f"Error submitting application: {e}")
            return False
```

## Environment Configuration - CRITICAL SETUP
```python
import os
from dotenv import load_dotenv

load_dotenv()

# Required environment variables for ADK
ENVIRONMENT = os.getenv("ENVIRONMENT", "development")
GOOGLE_CLOUD_PROJECT = os.getenv("GOOGLE_CLOUD_PROJECT")  # REQUIRED
GOOGLE_CLOUD_LOCATION = os.getenv("GOOGLE_CLOUD_LOCATION", "us-central1")  # REQUIRED
GOOGLE_GENAI_USE_VERTEXAI = os.getenv("GOOGLE_GENAI_USE_VERTEXAI", "true")  # REQUIRED

# Firebase
FIREBASE_CREDENTIALS_PATH = os.getenv("FIREBASE_CREDENTIALS_PATH", "config/firebase-credentials.json")

# ADK Configuration (optional)
ADK_BUCKET_NAME = os.getenv("ADK_BUCKET_NAME")

# Validation
required_vars = ["GOOGLE_CLOUD_PROJECT"]
for var_name in required_vars:
    if not os.getenv(var_name):
        raise ValueError(f"Required environment variable {var_name} is not set")
```

### .env.example Template - UPDATED WITH CORRECT VARIABLES
```bash
# Environment
ENVIRONMENT=development

# Google Cloud - REQUIRED for ADK/Vertex AI
GOOGLE_CLOUD_PROJECT=your-project-id
GOOGLE_CLOUD_LOCATION=us-central1
GOOGLE_GENAI_USE_VERTEXAI=true

# Firebase Authentication
# DEVELOPMENT: Use JSON service account file (downloaded from Firebase Console)
FIREBASE_CREDENTIALS_PATH=config/firebase-credentials.json

# PRODUCTION: Use Cloud Run's built-in service account (recommended)
# - Don't set FIREBASE_CREDENTIALS_PATH in production
# - Cloud Run automatically provides authentication
# - More secure than embedding JSON files in containers

# ADK Configuration (optional)
ADK_BUCKET_NAME=your-bucket-name

# Cloud Run Deployment Settings
PORT=8080                    # Cloud Run uses port 8080
MAINTENANCE_MODE=false       # Set to 'true' for maintenance mode deployment
```

## Google Cloud Setup - CRITICAL STEPS

### 1. Enable Required APIs
Before running the application, you MUST enable these APIs in Google Cloud Console:
```bash
# Visit these URLs to enable APIs:
# https://console.developers.google.com/apis/api/aiplatform.googleapis.com/overview?project=YOUR_PROJECT_ID
# https://console.developers.google.com/apis/api/vertexai.googleapis.com/overview?project=YOUR_PROJECT_ID
```

### 2. Authentication Setup
```bash
# Install Google Cloud SDK
brew install google-cloud-sdk  # macOS
# or follow instructions for other platforms

# Authenticate
gcloud auth login
gcloud auth application-default login
gcloud config set project YOUR_PROJECT_ID
```

### 3. Project Configuration
Ensure your Google Cloud project has:
- âœ… Vertex AI API enabled
- âœ… Application Default Credentials configured
- âœ… Project ID set in environment variables

## Development Dependencies (pyproject.toml)
```toml
[project]
name = "laiers"
version = "0.1.0"
dependencies = [
    "google-adk",           # Primary dependency - provides FastAPI integration
    "fastapi",
    "jinja2", 
    "python-multipart",
    "google-cloud-firestore", 
    "firebase-admin",
    "pydantic[email]",
    "python-dotenv",
    "uvicorn[standard]",
    "httpx"                 # For internal ADK API calls
]

[tool.uv]
dev-dependencies = [
    "pytest",
    "black", 
    "ruff"
]
```

## Development URLs and Endpoints

### Main Application URLs
- **Landing Page**: `http://localhost:8000/`
- **Registration**: `http://localhost:8000/register?user_type=talent|company`
- **Login**: `http://localhost:8000/login`
- **Dashboard**: `http://localhost:8000/dashboard` (requires auth)

### Opportunity Management URLs - NEW FEATURE
- **Company Portal**: `http://localhost:8000/company/{company_id}` - Company page with opportunities list
- **Create Opportunity**: `http://localhost:8000/company/{company_id}/opportunities/create` - AI-guided creation
- **Browse Opportunities**: `http://localhost:8000/opportunities` - All opportunities (talent users)
- **Opportunity Details**: `http://localhost:8000/opportunities/{opportunity_id}` - Job details + application
- **Apply to Opportunity**: `POST /api/opportunities/{opportunity_id}/apply` - Submit application
- **Create Opportunity API**: `POST /api/opportunities/create` - HTMX chat during creation

### ADK Integration URLs - VERIFIED WORKING
- **ADK Dev UI**: `http://localhost:8000/adk/dev-ui/` (note trailing slash!)
- **ADK API Docs**: `http://localhost:8000/adk/docs`
- **Agent Test**: `http://localhost:8000/test/adk-complete-flow` (custom test endpoint)

### Debug URLs
- **Debug Agent**: `http://localhost:8000/debug/adk`
- **Health Check**: `http://localhost:8000/health`
- **Test Opportunities**: `http://localhost:8000/test/opportunities/{company_id}` - Debug opportunities

## Coding Rules

### What to ALWAYS do:
- **ADK Integration**: Mount ADK app under `/adk` prefix, never replace main app
- **Agent Structure**: Use required `job_matching_agent/` directory with `root_agent` variable
- **Template Organization**: Two-panel dashboard (profile + chat), component-based HTMX responses
- **Firebase Auth**: Use session cookies, not JWT tokens in requests
- **Context Passing**: Always pass user context to ADK agent (user_type, etc.)
- **Error Handling**: Use try/except blocks with proper logging
- **HTMX Patterns**: Form-based chat interface, partial template responses
- **Environment Config**: Load all config from environment variables with proper validation
- **Google Cloud Setup**: Always verify Vertex AI API is enabled before deployment
- **ADK Communication**: Use HTTP client to call ADK endpoints internally, not direct imports

### Template Patterns:
- **Dashboard**: Two-panel grid layout (profile left, chat right)
- **Chat Interface**: HTMX form with `hx-post="/api/chat"` targeting messages container
- **HTMX Responses**: Return `components/chat_message.html` for new messages
- **Mobile Responsive**: Grid collapses to single column on mobile
- **User Context**: Show different chat welcome based on user_type

### ADK-Specific Rules - UPDATED BASED ON TESTING:
- **Agent Discovery**: ADK looks for `root_agent` variable in agent directory
- **Mounting**: Mount ADK app under path, don't replace main FastAPI app
- **Dev UI**: Always accessible at `/adk/dev-ui/` (with trailing slash)
- **Agent Communication**: Use HTTP calls to `/adk/run` endpoint, not direct Runner imports
- **Environment Variables**: Must have `GOOGLE_CLOUD_PROJECT` and `GOOGLE_CLOUD_LOCATION`
- **API Dependencies**: Vertex AI API must be enabled in Google Cloud Console
- **Authentication**: Use Application Default Credentials (gcloud auth application-default login)

### What to NEVER suggest:
- **Replacing ADK patterns**: Don't suggest alternatives to ADK's agent structure
- **Complex JavaScript**: Keep HTMX-only, minimal custom JS
- **Alternative auth**: Firebase only, no custom JWT handling
- **Database alternatives**: Firestore only, no SQLite/PostgreSQL
- **Microservices**: Single application with mounted sub-apps only
- **Different agent frameworks**: ADK only, no LangChain/CrewAI alternatives
- **Direct ADK imports**: Use HTTP API calls, not direct Python imports of ADK classes

### Error Handling Pattern - UPDATED:
```python
try:
    # ADK agent interaction via HTTP
    payload = {
        "appName": "job_matching_agent",
        "userId": user["uid"],
        "sessionId": f"session_{user['uid']}",
        "newMessage": {"role": "user", "parts": [{"text": message}]},
        "streaming": False
    }
    
    async with httpx.AsyncClient() as client:
        response = await client.post("http://localhost:8000/adk/run", json=payload)
        if response.status_code == 200:
            agent_data = response.json()
            agent_response = agent_data[0]["content"]["parts"][0]["text"]
        else:
            raise Exception(f"ADK API error: {response.status_code}")
    
    return templates.TemplateResponse("components/chat_message.html", {
        "request": request,
        "user_message": message,
        "agent_response": agent_response,
        "timestamp": datetime.now()
    })
except Exception as e:
    logger.error(f"Chat error: {e}")
    return templates.TemplateResponse("components/chat_error.html", {
        "request": request,
        "error": "Failed to process message"
    })
```

## Cloud Run Deployment - PRODUCTION READY

### Complete Deployment System
The application includes a full Cloud Run deployment system with maintenance mode:

**Key Files:**
- **`Dockerfile`**: UV-optimized container for Cloud Run
- **`.dockerignore`**: Optimized build context exclusions
- **`deployment/deploy.sh`**: Full-featured deployment script
- **`deployment/quick-deploy.sh`**: Quick commands for common operations
- **`deployment/README.md`**: Comprehensive deployment documentation
- **`utils/middleware.py`**: Maintenance mode middleware

### Maintenance Mode System
- **Safe Deployments**: Deploy in maintenance mode first
- **Professional UI**: Beautiful "Coming Soon" page during maintenance
- **Health Checks**: Always accessible even during maintenance (`/health`, `/_ah/health`)
- **Instant Toggle**: Switch live/maintenance without rebuilding
- **Environment Control**: Uses `MAINTENANCE_MODE` environment variable

### Deployment Commands
```bash
# Quick deployment workflow
./deployment/quick-deploy.sh deploy      # Deploy in maintenance mode
./deployment/quick-deploy.sh live        # Make app live
./deployment/quick-deploy.sh maintenance # Back to maintenance mode
./deployment/quick-deploy.sh url         # Get service URL
./deployment/quick-deploy.sh logs        # View logs

# Full-featured commands
./deployment/deploy.sh deploy            # Deploy with all options
./deployment/deploy.sh status            # Service status
./deployment/deploy.sh logs              # Comprehensive logs
```

### Production Configuration
- **Application Default Credentials**: No JSON files in containers
- **Environment Variables**: All config via Cloud Run environment
- **Auto-scaling**: Scales to zero for cost optimization
- **Health Monitoring**: Multiple health check endpoints
- **Security**: Non-root container user, minimal attack surface

## Development Focus
- **MVP Prototype**: Focus on core user flow (signup â†’ dashboard â†’ chat)
- **User Types**: "company" and "talent" only, single agent handles both
- **Context-Aware Agent**: Agent adapts responses based on user_type
- **Clean Integration**: Custom UI + ADK backend, not ADK's default UI
- **Template-First**: Design templates before implementing routes
- **Responsive Design**: Mobile-friendly two-panel layout
- **Opportunity Management**: Complete job posting and application workflow
- **AI-Guided Creation**: Use ADK agent for structured opportunity creation
- **HTMX Interactions**: Dynamic forms and partial page updates
- **Firestore Integration**: All data stored in Firestore collections
- **Production Ready**: Complete Cloud Run deployment with maintenance mode

## Common Mistakes to Avoid - UPDATED
- **Wrong ADK mounting**: Don't use ADK app as main app, mount under `/adk`
- **Missing trailing slash**: ADK dev UI needs `/adk/dev-ui/` not `/adk/dev-ui`
- **Agent structure**: Must have `job_matching_agent/` directory with `root_agent`
- **Template context**: Always pass `request` object to template responses
- **User context**: Don't forget to pass user_type to agent for personalization
- **HTMX targets**: Use correct selectors for message container updates
- **Environment variables**: Use `GOOGLE_CLOUD_LOCATION` not `VERTEX_AI_LOCATION`
- **API not enabled**: Always check Vertex AI API is enabled in Google Cloud Console
- **Authentication**: Must run `gcloud auth application-default login`
- **Direct imports**: Don't import ADK classes directly, use HTTP API

## Troubleshooting - CRITICAL ISSUES

### ADK Agent Not Working (500 Error)
1. **Check Vertex AI API**: Visit `https://console.developers.google.com/apis/api/aiplatform.googleapis.com/overview?project=YOUR_PROJECT_ID`
2. **Verify Authentication**: Run `gcloud auth application-default login`
3. **Check Environment**: Ensure `GOOGLE_CLOUD_PROJECT` and `GOOGLE_CLOUD_LOCATION` are set
4. **Test Connection**: Use `/test/adk-complete-flow` endpoint to verify setup

### Session Already Exists (400 Error)
This is NORMAL behavior. ADK reuses existing sessions. Only worry if message sending fails.

### 403 Permission Denied
- Enable Vertex AI API in Google Cloud Console
- Wait 2-3 minutes after enabling
- Verify project ID matches in environment variables

### Cloud Run Deployment Issues - NEW TROUBLESHOOTING

**1. Project ID vs Project Number Error**
```bash
# Fix gcloud config to use project ID, not project number
gcloud config set project your-project-id  # Use string, not number
gcloud auth application-default set-quota-project your-project-id
```

**2. Container Build Failures**
- **Missing uv.lock**: Ensure `uv.lock` is NOT in `.dockerignore`
- **Permission Issues**: Dependencies installed as root in Dockerfile
- **Port Configuration**: Use `--port=8080`, not `PORT=8080` environment variable

**3. Container Startup Failures**
- **Firebase Config**: Use Application Default Credentials in production
- **Environment Variables**: Set all required variables during deployment
- **Project ID Missing**: Ensure `GOOGLE_CLOUD_PROJECT` is set in Cloud Run

**4. Environment Variable Loss During Updates**
```bash
# WRONG - loses other environment variables
gcloud run services update SERVICE --set-env-vars="MAINTENANCE_MODE=true"

# CORRECT - preserves all environment variables
gcloud run services update SERVICE --set-env-vars="MAINTENANCE_MODE=true,ENVIRONMENT=production,GOOGLE_CLOUD_PROJECT=project-id,GOOGLE_CLOUD_LOCATION=us-central1,GOOGLE_GENAI_USE_VERTEXAI=true"
```

**5. Deployment Debug Commands**
```bash
# Check service status
./deployment/deploy.sh status

# View deployment logs
./deployment/deploy.sh logs

# Test health endpoint
curl "$(./deployment/quick-deploy.sh url)/health"

# Check environment variables
gcloud run services describe SERVICE_NAME --region us-central1 --format="yaml" | grep -A 20 "env:"
```

When writing code, always reference these ADK integration patterns. The key insight is that ADK provides the agent backend while your FastAPI app provides the custom authentication and user interface layer. **Always verify Google Cloud setup before troubleshooting code issues.**

**For deployment issues, check `deployment/README.md` for comprehensive troubleshooting guide.**