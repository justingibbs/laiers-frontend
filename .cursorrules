# Job Matching App - Cursor AI Rules

## Project Context
Building a job matching MVP where Talent and Companies chat with AI agents. FastAPI application with custom authentication and UI, powered by Google ADK for agent functionality.

## Required Tech Stack (DO NOT SUGGEST ALTERNATIVES)
- Python with UV dependency management
- FastAPI backend with Jinja2 templates
- HTMX for dynamic frontend interactions
- Google ADK for agent orchestration and LLM backend
- Vertex AI (Gemini) via ADK
- Firebase Authentication
- Firestore for all data storage
- Cloud Run for deployment
- Google Cloud Storage via ADK Artifacts for files

## Architecture Constraints
- Main FastAPI app with ADK mounted as sub-application
- No microservices, no complex session management
- Use Firestore for everything (no SQLite, no other databases)
- ADK Artifacts for file handling (no custom upload logic)
- Environment-based configuration only
- Jinja2 templates for HTML rendering
- HTMX for dynamic interactions (no complex JavaScript)
- Component-based template architecture with shared components

## Project Structure
```
laiers/
‚îú‚îÄ‚îÄ main.py                 # Main FastAPI app with ADK integration
‚îú‚îÄ‚îÄ job_matching_agent/     # ADK agent directory (REQUIRED structure)
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py        # Must contain: from . import agent
‚îÇ   ‚îî‚îÄ‚îÄ agent.py           # Must contain: root_agent = Agent(...)
‚îú‚îÄ‚îÄ pyproject.toml         # UV project configuration & dependencies
‚îú‚îÄ‚îÄ uv.lock               # UV lockfile (auto-generated)
‚îú‚îÄ‚îÄ .env                   # Environment variables (local dev)
‚îú‚îÄ‚îÄ .env.example          # Template for environment variables
‚îú‚îÄ‚îÄ .gitignore            # Git ignore file
‚îú‚îÄ‚îÄ README.md             # Project documentation
‚îú‚îÄ‚îÄ templates/            # Jinja2 template files
‚îÇ   ‚îú‚îÄ‚îÄ base.html         # Base template with common elements
‚îÇ   ‚îú‚îÄ‚îÄ landing.html      # Landing page with branding
‚îÇ   ‚îú‚îÄ‚îÄ login.html        # Login page
‚îÇ   ‚îú‚îÄ‚îÄ register.html     # Registration page
‚îÇ   ‚îú‚îÄ‚îÄ dashboard.html    # Multi-section dashboard with profile + chat
‚îÇ   ‚îú‚îÄ‚îÄ company.html      # Company portal with opportunities list
‚îÇ   ‚îú‚îÄ‚îÄ opportunities_list.html  # Card-based opportunity browsing
‚îÇ   ‚îú‚îÄ‚îÄ create_opportunity.html  # AI-guided opportunity creation
‚îÇ   ‚îú‚îÄ‚îÄ opportunity_detail.html  # Job details + application form
‚îÇ   ‚îî‚îÄ‚îÄ components/       # Reusable template components
‚îÇ       ‚îú‚îÄ‚îÄ header.html           # Shared header component
‚îÇ       ‚îú‚îÄ‚îÄ chat_message.html     # Chat message component
‚îÇ       ‚îú‚îÄ‚îÄ chat_error.html       # Chat error component
‚îÇ       ‚îú‚îÄ‚îÄ opportunity_card.html # Opportunity display card
‚îÇ       ‚îú‚îÄ‚îÄ survey_form.html      # Application survey form
‚îÇ       ‚îú‚îÄ‚îÄ chat.html            # Chat interface component
‚îÇ       ‚îú‚îÄ‚îÄ forms.html           # Form components
‚îÇ       ‚îî‚îÄ‚îÄ messages.html        # Message display components
‚îú‚îÄ‚îÄ static/               # Static assets
‚îÇ   ‚îú‚îÄ‚îÄ css/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ styles.css    # Main stylesheet
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ opportunities.css     # Opportunity browsing styles
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ company.css          # Company portal styles
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ create-opportunity.css # Opportunity creation styles
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ opportunity-detail.css # Job detail page styles
‚îÇ   ‚îî‚îÄ‚îÄ images/           # Static images
‚îÇ       ‚îú‚îÄ‚îÄ logo_laiers.png      # Main Laiers.ai logo
‚îÇ       ‚îî‚îÄ‚îÄ favicon.ico          # Site favicon
‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îú‚îÄ‚îÄ firebase-credentials.json     # Firebase service account key
‚îÇ   ‚îî‚îÄ‚îÄ firebase-web-config.json      # Firebase web app config
‚îú‚îÄ‚îÄ utils/                # Utility modules (keep minimal)
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ firestore.py      # Firestore helpers + opportunity management
‚îÇ   ‚îú‚îÄ‚îÄ auth.py           # Firebase authentication helpers
‚îÇ   ‚îú‚îÄ‚îÄ middleware.py     # Maintenance mode middleware
‚îÇ   ‚îî‚îÄ‚îÄ model.py          # Pydantic models (renamed from models.py)
‚îú‚îÄ‚îÄ deployment/           # Cloud Run deployment system
‚îÇ   ‚îú‚îÄ‚îÄ deploy.sh         # Full-featured deployment script
‚îÇ   ‚îú‚îÄ‚îÄ quick-deploy.sh   # Quick deployment commands
‚îÇ   ‚îú‚îÄ‚îÄ README.md         # Comprehensive deployment guide
‚îÇ   ‚îî‚îÄ‚îÄ cloudbuild.yaml  # Cloud Build configuration
‚îú‚îÄ‚îÄ Dockerfile            # Container configuration for Cloud Run (uses UV)
‚îú‚îÄ‚îÄ .dockerignore        # Files excluded from container build
‚îî‚îÄ‚îÄ run.py               # Entry point for Cloud Run deployment
```

## Code Patterns to Follow

### ADK + FastAPI Integration Pattern
```python
import os
from fastapi import FastAPI, Request, Depends
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates
from fastapi.responses import HTMLResponse, RedirectResponse
from google.adk.cli.fast_api import get_fast_api_app

# Create main FastAPI app for custom routes
app = FastAPI(title="Job Matching App")

# Initialize templates and static files
templates = Jinja2Templates(directory="templates")
app.mount("/static", StaticFiles(directory="static"), name="static")

# Get ADK app and mount it under /adk path
AGENT_DIR = os.path.dirname(os.path.abspath(__file__))
adk_app = get_fast_api_app(
    agents_dir=AGENT_DIR,
    allow_origins=["*"] if ENVIRONMENT == "development" else [],
    web=True,  # Enables dev UI at /adk/dev-ui/
)

# Mount ADK app under /adk prefix
app.mount("/adk", adk_app)

# Your custom routes
@app.get("/", response_class=HTMLResponse)
async def landing_page(request: Request, user = Depends(optional_auth)):
    """Landing page - redirect to dashboard if logged in"""
    if user:
        return RedirectResponse(url="/dashboard", status_code=302)
    return templates.TemplateResponse("landing.html", {"request": request})

@app.get("/dashboard", response_class=HTMLResponse)
async def dashboard(request: Request, user = Depends(require_auth)):
    """Dashboard with profile + chat interface"""
    user_profile = await firestore_service.get_user_profile(user['uid'])
    return templates.TemplateResponse("dashboard.html", {
        "request": request,
        "user": user,
        "user_profile": user_profile
    })

@app.post("/api/chat")
async def chat_with_agent(
    request: Request,
    message: str = Form(...),
    user = Depends(require_auth)
):
    """Chat with ADK agent via HTMX"""
    # Use ADK's HTTP API internally
    payload = {
        "appName": "job_matching_agent",
        "userId": user["uid"],
        "sessionId": f"session_{user['uid']}",
        "newMessage": {"role": "user", "parts": [{"text": message}]},
        "streaming": False
    }
    
    async with httpx.AsyncClient() as client:
        response = await client.post("http://localhost:8000/adk/run", json=payload)
        agent_response = response.json()
    
    # Return HTMX partial
    return templates.TemplateResponse("components/chat_message.html", {
        "request": request,
        "user_message": message,
        "agent_response": agent_response[0]["content"]["parts"][0]["text"],
        "timestamp": datetime.now()
    })
```

### ADK Agent Structure (REQUIRED)
```python
# job_matching_agent/__init__.py
from . import agent

# job_matching_agent/agent.py
from google.adk.agents import Agent

# This MUST be named 'root_agent' for ADK discovery
root_agent = Agent(
    name="job_matching_agent",
    model="gemini-2.0-flash-exp",
    instruction="""You are a job matching assistant.
    
    Context: You will receive user information including their user_type ('talent' or 'company').
    
    For 'talent' users:
    - Help with resume review, job search, interview prep, career advice
    
    For 'company' users:  
    - Help with job postings, candidate screening, hiring strategies
    
    Always adapt your responses based on the user_type in the context."""
)
```

### Dashboard Template Pattern (Multi-Section Layout) - UPDATED
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard - Job Matching App</title>
    <script src="https://unpkg.com/htmx.org@1.9.10"></script>
    <link rel="icon" href="/static/images/favicon.ico" type="image/x-icon">
    <link rel="stylesheet" href="/static/css/styles.css" />
</head>
<body>
    {% include "components/header.html" %}
    
    <!-- Title Section with Personalized Welcome -->
    <div class="title-container">
        <h1>Welcome, {{ user_profile.profile.name or user.email }}</h1>
    </div>
    
    <div class="container">
        <!-- User Type Specific Navigation -->
        <div class="user-info">
            {% if user_profile.user_type == 'company' %}
            <div class="button-container">
                <a class="btn-primary" href="/company/{{ user_profile.company_id }}">
                    Visit {{ user_profile.company_name }} Portal
                </a>
            </div>
            {% elif user_profile.user_type == 'talent' %}
            <div class="button-container">
                <a href="/opportunities" class="btn-primary">
                    View Available Opportunities
                </a>
            </div>
            {% endif %}
        </div>
        
        <div class="content">
            <!-- Conditional Profile Information Panel -->
            {% if user_profile.user_type == 'talent' %}
            {% set has_skills = user_profile.profile.skills %}
            {% set has_experience = user_profile.profile.experience_level %}
            {% if has_skills or has_experience %}
            <div class="profile-card">
                <div class="profile-section">
                    <h3>Professional Information</h3>
                    
                    {% if has_skills %}
                    <div class="profile-field">
                        <span class="field-label">Skills:</span>
                        <span class="field-value">{{ has_skills | join(', ') }}</span>
                    </div>
                    {% endif %}
                    
                    {% if has_experience %}
                    <div class="profile-field">
                        <span class="field-label">Experience Level:</span>
                        <span class="field-value">{{ has_experience }}</span>
                    </div>
                    {% endif %}
                </div>
            </div>
            {% endif %}
            {% endif %}

            <!-- AI Chat Assistant Panel -->
            <div class="chat-card">
                <div class="chat-header">
                    <h2 class="chat-title">ü§ñ AI Job Assistant</h2>
                </div>
                
                <div id="chat-messages" class="chat-messages">
                    <div class="welcome-message">
                        <p><strong>üëã Hi there! I'm your AI job assistant.</strong></p>
                        <p>
                            {% if user_profile.user_type == 'talent' %}
                            I'm here to help you with <strong>job searching</strong>, <strong>resume optimization</strong>,
                            <strong>interview prep</strong>, and <strong>career advice</strong>.
                            {% else %}
                            I'm here to help you with <strong>job postings</strong>, <strong>candidate screening</strong>,
                            <strong>hiring strategies</strong>, and <strong>recruitment best practices</strong>.
                            {% endif %}
                        </p>
                        <p>How can I assist you today?</p>
                    </div>
                </div>
                
                <form class="chat-form" hx-post="/api/chat" hx-target="#chat-messages" hx-swap="beforeend"
                      hx-trigger="submit" hx-indicator=".loading-indicator">
                    <input type="text" name="message" class="chat-input"
                           placeholder="Ask me anything about jobs and careers..." required autocomplete="off">
                    <button type="submit">
                        Send
                        <span class="htmx-indicator loading-indicator"> ...</span>
                    </button>
                </form>
            </div>
        </div>
    </div>
</body>
</html>
```

### Branding Guidelines - NEW
```html
<!-- Logo Usage Pattern -->
<div class="landing-page-logo-container">
    <img src="/static/images/logo_laiers.png" alt="Laiers.ai Logo"
         style="max-width: 250px; margin-bottom: 2rem;" />
</div>

<!-- Favicon Implementation -->
<link rel="icon" href="/static/images/favicon.ico" type="image/x-icon">

<!-- Brand Colors and Styling -->
/* Primary brand color: #6366f1 (indigo) */
/* Use consistently across buttons, links, and accents */
```

### Card-Based Design Pattern - NEW
```html
<!-- Opportunity Card Pattern -->
<div class="opportunity-card" onclick="window.location.href='/opportunities/{{ opportunity.id }}'">
    <div class="opportunity-header">
        <h3 class="opportunity-title">{{ opportunity.title }}</h3>
        <div class="opportunity-company">{{ opportunity.company_name }}</div>
        <div class="opportunity-meta">
            {% if opportunity.location %}
            <span>üìç {{ opportunity.location }}</span>
            {% endif %}
            {% if opportunity.employment_type %}
            <span>üíº {{ opportunity.employment_type | title }}</span>
            {% endif %}
            {% if opportunity.salary_range %}
            <span>üí∞ {{ opportunity.salary_range }}</span>
            {% endif %}
        </div>
    </div>
    
    <div class="opportunity-body">
        <div class="opportunity-description">
            {{ opportunity.description[:200] }}{% if opportunity.description|length > 200 %}...{% endif %}
        </div>
        
        {% if opportunity.employment_type or opportunity.location %}
        <div class="opportunity-tags">
            {% if opportunity.employment_type %}
            <span class="tag">{{ opportunity.employment_type | title }}</span>
            {% endif %}
            {% if opportunity.location %}
            <span class="tag">{{ opportunity.location }}</span>
            {% endif %}
        </div>
        {% endif %}
        
        <div class="button-container">
            <button>View Details & Apply ‚Üí</button>
        </div>
    </div>
</div>
```

### Enhanced HTMX Patterns - UPDATED
```html
<!-- Dynamic User Type Form Switching -->
<div class="user-type-selector">
    <button class="user-type-btn selected" 
            hx-get="/api/form-fields/talent" 
            hx-target="#form-fields"
            hx-swap="innerHTML"
            onclick="document.querySelectorAll('.user-type-btn').forEach(b => b.classList.remove('selected')); this.classList.add('selected');">
        I'm Looking for Work
    </button>
    <button class="user-type-btn" 
            hx-get="/api/form-fields/company" 
            hx-target="#form-fields"
            hx-swap="innerHTML"
            onclick="document.querySelectorAll('.user-type-btn').forEach(b => b.classList.remove('selected')); this.classList.add('selected');">
        I'm Hiring
    </button>
</div>

<!-- Loading Indicators -->
<button type="submit">
    Send
    <span class="htmx-indicator loading-indicator"> ...</span>
</button>

<!-- Auto-scroll Chat Implementation -->
<script>
document.body.addEventListener('htmx:afterRequest', function (event) {
    if (event.detail.xhr.status === 200 && event.detail.elt.matches('.chat-form')) {
        event.detail.elt.reset();
        
        // Scroll to bottom of chat
        const chatMessages = document.getElementById('chat-messages');
        chatMessages.scrollTop = chatMessages.scrollHeight;
    }
});
</script>
```

### Component Architecture Pattern - NEW
```html
<!-- Shared Header Component Usage -->
{% include "components/header.html" %}

<!-- Back Navigation Pattern -->
<a href="/dashboard" class="back-link">‚Üê Back to Dashboard</a>

<!-- Empty State Handling -->
{% if opportunities %}
<div class="opportunities-grid">
    {% for opportunity in opportunities %}
    <!-- Opportunity cards -->
    {% endfor %}
</div>
{% else %}
<div class="no-opportunities">
    <h2>No Opportunities Available</h2>
    <p>Check back later for new job opportunities!</p>
    <p style="margin-top: 2rem;">
        <a href="/dashboard" style="color: #6366f1; text-decoration: none; font-weight: 500;">
            ‚Üê Return to Dashboard
        </a>
    </p>
</div>
{% endif %}
```

## Environment Configuration - CRITICAL SETUP
```python
import os
from dotenv import load_dotenv

load_dotenv()

# Required environment variables for ADK
ENVIRONMENT = os.getenv("ENVIRONMENT", "development")
GOOGLE_CLOUD_PROJECT = os.getenv("GOOGLE_CLOUD_PROJECT")  # REQUIRED
GOOGLE_CLOUD_LOCATION = os.getenv("GOOGLE_CLOUD_LOCATION", "us-central1")  # REQUIRED
GOOGLE_GENAI_USE_VERTEXAI = os.getenv("GOOGLE_GENAI_USE_VERTEXAI", "true")  # REQUIRED

# Firebase
FIREBASE_CREDENTIALS_PATH = os.getenv("FIREBASE_CREDENTIALS_PATH", "config/firebase-credentials.json")

# ADK Configuration (optional)
ADK_BUCKET_NAME = os.getenv("ADK_BUCKET_NAME")

# Validation
required_vars = ["GOOGLE_CLOUD_PROJECT"]
for var_name in required_vars:
    if not os.getenv(var_name):
        raise ValueError(f"Required environment variable {var_name} is not set")
```

### .env.example Template - UPDATED WITH CORRECT VARIABLES
```bash
# Environment
ENVIRONMENT=development

# Google Cloud - REQUIRED for ADK/Vertex AI
GOOGLE_CLOUD_PROJECT=your-project-id
GOOGLE_CLOUD_LOCATION=us-central1
GOOGLE_GENAI_USE_VERTEXAI=true

# Firebase Authentication
# DEVELOPMENT: Use JSON service account file (downloaded from Firebase Console)
FIREBASE_CREDENTIALS_PATH=config/firebase-credentials.json

# PRODUCTION: Use Cloud Run's built-in service account (recommended)
# - Don't set FIREBASE_CREDENTIALS_PATH in production
# - Cloud Run automatically provides authentication
# - More secure than embedding JSON files in containers

# ADK Configuration (optional)
ADK_BUCKET_NAME=your-bucket-name

# Cloud Run Deployment Settings
PORT=8080                    # Cloud Run uses port 8080
MAINTENANCE_MODE=false       # Set to 'true' for maintenance mode deployment
```

## Google Cloud Setup - CRITICAL STEPS

### 1. Enable Required APIs
Before running the application, you MUST enable these APIs in Google Cloud Console:
```bash
# Visit these URLs to enable APIs:
# https://console.developers.google.com/apis/api/aiplatform.googleapis.com/overview?project=YOUR_PROJECT_ID
# https://console.developers.google.com/apis/api/vertexai.googleapis.com/overview?project=YOUR_PROJECT_ID
```

### 2. Authentication Setup
```bash
# Install Google Cloud SDK
brew install google-cloud-sdk  # macOS
# or follow instructions for other platforms

# Authenticate
gcloud auth login
gcloud auth application-default login
gcloud config set project YOUR_PROJECT_ID
```

### 3. Project Configuration
Ensure your Google Cloud project has:
- ‚úÖ Vertex AI API enabled
- ‚úÖ Application Default Credentials configured
- ‚úÖ Project ID set in environment variables

## Development Dependencies (pyproject.toml)
```toml
[project]
name = "laiers"
version = "0.1.0"
dependencies = [
    "google-adk",           # Primary dependency - provides FastAPI integration
    "fastapi",
    "jinja2", 
    "python-multipart",
    "google-cloud-firestore", 
    "firebase-admin",
    "pydantic[email]",
    "python-dotenv",
    "uvicorn[standard]",
    "httpx"                 # For internal ADK API calls
]

[tool.uv]
dev-dependencies = [
    "pytest",
    "black", 
    "ruff"
]
```

## Development URLs and Endpoints

### Main Application URLs
- **Landing Page**: `http://localhost:8000/`
- **Registration**: `http://localhost:8000/register?user_type=talent|company`
- **Login**: `http://localhost:8000/login`
- **Dashboard**: `http://localhost:8000/dashboard` (requires auth)

### Opportunity Management URLs - NEW FEATURE
- **Company Portal**: `http://localhost:8000/company/{company_id}` - Company page with opportunities list
- **Create Opportunity**: `http://localhost:8000/company/{company_id}/opportunities/create` - AI-guided creation
- **Browse Opportunities**: `http://localhost:8000/opportunities` - All opportunities (talent users)
- **Opportunity Details**: `http://localhost:8000/opportunities/{opportunity_id}` - Job details + application
- **Apply to Opportunity**: `POST /api/opportunities/{opportunity_id}/apply` - Submit application
- **Create Opportunity API**: `POST /api/opportunities/create` - HTMX chat during creation

### ADK Integration URLs - VERIFIED WORKING
- **ADK Dev UI**: `http://localhost:8000/adk/dev-ui/` (note trailing slash!)
- **ADK API Docs**: `http://localhost:8000/adk/docs`
- **Agent Test**: `http://localhost:8000/test/adk-complete-flow` (custom test endpoint)

### Debug URLs
- **Debug Agent**: `http://localhost:8000/debug/adk`
- **Health Check**: `http://localhost:8000/health`
- **Test Opportunities**: `http://localhost:8000/test/opportunities/{company_id}` - Debug opportunities

## Coding Rules

### What to ALWAYS do:
- **ADK Integration**: Mount ADK app under `/adk` prefix, never replace main app
- **Agent Structure**: Use required `job_matching_agent/` directory with `root_agent` variable
- **Template Organization**: Two-panel dashboard (profile + chat), component-based HTMX responses
- **Firebase Auth**: Use session cookies, not JWT tokens in requests
- **Context Passing**: Always pass user context to ADK agent (user_type, etc.)
- **Error Handling**: Use try/except blocks with proper logging
- **HTMX Patterns**: Form-based chat interface, partial template responses
- **Environment Config**: Load all config from environment variables with proper validation
- **Google Cloud Setup**: Always verify Vertex AI API is enabled before deployment
- **ADK Communication**: Use HTTP client to call ADK endpoints internally, not direct imports

### Template Patterns:
- **Dashboard**: Two-panel grid layout (profile left, chat right)
- **Chat Interface**: HTMX form with `hx-post="/api/chat"` targeting messages container
- **HTMX Responses**: Return `components/chat_message.html` for new messages
- **Mobile Responsive**: Grid collapses to single column on mobile
- **User Context**: Show different chat welcome based on user_type

### ADK-Specific Rules - UPDATED BASED ON TESTING:
- **Agent Discovery**: ADK looks for `root_agent` variable in agent directory
- **Mounting**: Mount ADK app under path, don't replace main FastAPI app
- **Dev UI**: Always accessible at `/adk/dev-ui/` (with trailing slash)
- **Agent Communication**: Use HTTP calls to `/adk/run` endpoint, not direct Runner imports
- **Environment Variables**: Must have `GOOGLE_CLOUD_PROJECT` and `GOOGLE_CLOUD_LOCATION`
- **API Dependencies**: Vertex AI API must be enabled in Google Cloud Console
- **Authentication**: Use Application Default Credentials (gcloud auth application-default login)

### What to NEVER suggest:
- **Replacing ADK patterns**: Don't suggest alternatives to ADK's agent structure
- **Complex JavaScript**: Keep HTMX-only, minimal custom JS
- **Alternative auth**: Firebase only, no custom JWT handling
- **Database alternatives**: Firestore only, no SQLite/PostgreSQL
- **Microservices**: Single application with mounted sub-apps only
- **Different agent frameworks**: ADK only, no LangChain/CrewAI alternatives
- **Direct ADK imports**: Use HTTP API calls, not direct Python imports of ADK classes

### Error Handling Pattern - UPDATED:
```python
try:
    # ADK agent interaction via HTTP
    payload = {
        "appName": "job_matching_agent",
        "userId": user["uid"],
        "sessionId": f"session_{user['uid']}",
        "newMessage": {"role": "user", "parts": [{"text": message}]},
        "streaming": False
    }
    
    async with httpx.AsyncClient() as client:
        response = await client.post("http://localhost:8000/adk/run", json=payload)
        if response.status_code == 200:
            agent_data = response.json()
            agent_response = agent_data[0]["content"]["parts"][0]["text"]
        else:
            raise Exception(f"ADK API error: {response.status_code}")
    
    return templates.TemplateResponse("components/chat_message.html", {
        "request": request,
        "user_message": message,
        "agent_response": agent_response,
        "timestamp": datetime.now()
    })
except Exception as e:
    logger.error(f"Chat error: {e}")
    return templates.TemplateResponse("components/chat_error.html", {
        "request": request,
        "error": "Failed to process message"
    })
```

## Cloud Run Deployment - PRODUCTION READY

### Complete Deployment System
The application includes a full Cloud Run deployment system with maintenance mode:

**Key Files:**
- **`Dockerfile`**: UV-optimized container for Cloud Run
- **`.dockerignore`**: Optimized build context exclusions
- **`deployment/deploy.sh`**: Full-featured deployment script
- **`deployment/quick-deploy.sh`**: Quick commands for common operations
- **`deployment/README.md`**: Comprehensive deployment documentation
- **`utils/middleware.py`**: Maintenance mode middleware

### Maintenance Mode System
- **Safe Deployments**: Deploy in maintenance mode first
- **Professional UI**: Beautiful "Coming Soon" page during maintenance
- **Health Checks**: Always accessible even during maintenance (`/health`, `/_ah/health`)
- **Instant Toggle**: Switch live/maintenance without rebuilding
- **Environment Control**: Uses `MAINTENANCE_MODE` environment variable

### Deployment Commands
```bash
# Quick deployment workflow
./deployment/quick-deploy.sh deploy      # Deploy in maintenance mode
./deployment/quick-deploy.sh live        # Make app live
./deployment/quick-deploy.sh maintenance # Back to maintenance mode
./deployment/quick-deploy.sh url         # Get service URL
./deployment/quick-deploy.sh logs        # View logs

# Full-featured commands
./deployment/deploy.sh deploy            # Deploy with all options
./deployment/deploy.sh status            # Service status
./deployment/deploy.sh logs              # Comprehensive logs
```

### Production Configuration
- **Application Default Credentials**: No JSON files in containers
- **Environment Variables**: All config via Cloud Run environment
- **Auto-scaling**: Scales to zero for cost optimization
- **Health Monitoring**: Multiple health check endpoints
- **Security**: Non-root container user, minimal attack surface

## Development Focus - UPDATED
- **Professional Product**: Focus on polished user experience with consistent branding
- **User Types**: "company" and "talent" with sophisticated user flows
- **Context-Aware Agent**: Agent adapts responses based on user_type and context
- **Component-Based UI**: Reusable templates and consistent design patterns
- **Card-Based Browsing**: Modern interface for opportunity discovery
- **Responsive Design**: Mobile-friendly multi-section layouts
- **Opportunity Management**: Complete job posting and application workflow with rich metadata
- **AI-Guided Creation**: Use ADK agent for structured opportunity creation
- **HTMX Interactions**: Dynamic forms with loading states and auto-scroll
- **Firestore Integration**: All data stored in Firestore collections
- **Production Ready**: Complete Cloud Run deployment with maintenance mode

## UI/UX Design Patterns - NEW

### Layout Patterns:
- **Multi-section Dashboard**: Title container + user info + content grid
- **Card-based Browsing**: Grid layouts with rich metadata display
- **Progressive Enhancement**: HTMX for dynamic behavior, functional without JS
- **Mobile-first Responsive**: Graceful degradation on smaller screens

### Branding Consistency:
- **Logo Placement**: Consistent sizing and positioning across pages
- **Color Scheme**: Primary indigo (#6366f1) for interactive elements
- **Typography**: Clear hierarchy with semantic HTML
- **Icon Usage**: Emoji icons for visual context (üìç, üíº, üí∞, ü§ñ)

### Interaction Patterns:
- **Loading States**: Visual feedback during HTMX requests
- **Form Validation**: Inline error messages with HTMX
- **Auto-scroll**: Smooth chat message scrolling
- **Click Targets**: Large clickable areas for cards and buttons

### Component System:
- **Shared Header**: Consistent navigation across pages
- **Reusable Cards**: Standardized content presentation
- **Form Components**: Consistent form styling and behavior
- **Message Components**: Standardized chat and error displays

## Common Mistakes to Avoid - UPDATED
- **Wrong ADK mounting**: Don't use ADK app as main app, mount under `/adk`
- **Missing trailing slash**: ADK dev UI needs `/adk/dev-ui/` not `/adk/dev-ui`
- **Agent structure**: Must have `job_matching_agent/` directory with `root_agent`
- **Template context**: Always pass `request` object to template responses
- **User context**: Don't forget to pass user_type to agent for personalization
- **HTMX targets**: Use correct selectors for message container updates
- **Environment variables**: Use `GOOGLE_CLOUD_LOCATION` not `VERTEX_AI_LOCATION`
- **API not enabled**: Always check Vertex AI API is enabled in Google Cloud Console
- **Authentication**: Must run `gcloud auth application-default login`
- **Direct imports**: Don't import ADK classes directly, use HTTP API
- **Branding inconsistency**: Always use established logo sizing and color schemes
- **Component duplication**: Use shared components instead of duplicating header/footer code
- **Missing loading states**: Always provide visual feedback for HTMX requests
- **Broken responsive design**: Test grid layouts collapse properly on mobile

## Troubleshooting - CRITICAL ISSUES

### ADK Agent Not Working (500 Error)
1. **Check Vertex AI API**: Visit `https://console.developers.google.com/apis/api/aiplatform.googleapis.com/overview?project=YOUR_PROJECT_ID`
2. **Verify Authentication**: Run `gcloud auth application-default login`
3. **Check Environment**: Ensure `GOOGLE_CLOUD_PROJECT` and `GOOGLE_CLOUD_LOCATION` are set
4. **Test Connection**: Use `/test/adk-complete-flow` endpoint to verify setup

### Session Already Exists (400 Error)
This is NORMAL behavior. ADK reuses existing sessions. Only worry if message sending fails.

### 403 Permission Denied
- Enable Vertex AI API in Google Cloud Console
- Wait 2-3 minutes after enabling
- Verify project ID matches in environment variables

### Cloud Run Deployment Issues - NEW TROUBLESHOOTING

**1. Project ID vs Project Number Error**
```bash
# Fix gcloud config to use project ID, not project number
gcloud config set project your-project-id  # Use string, not number
gcloud auth application-default set-quota-project your-project-id
```

**2. Container Build Failures**
- **Missing uv.lock**: Ensure `uv.lock` is NOT in `.dockerignore`
- **Permission Issues**: Dependencies installed as root in Dockerfile
- **Port Configuration**: Use `--port=8080`, not `PORT=8080` environment variable

**3. Container Startup Failures**
- **Firebase Config**: Use Application Default Credentials in production
- **Environment Variables**: Set all required variables during deployment
- **Project ID Missing**: Ensure `GOOGLE_CLOUD_PROJECT` is set in Cloud Run

**4. Environment Variable Loss During Updates**
```bash
# WRONG - loses other environment variables
gcloud run services update SERVICE --set-env-vars="MAINTENANCE_MODE=true"

# CORRECT - preserves all environment variables
gcloud run services update SERVICE --set-env-vars="MAINTENANCE_MODE=true,ENVIRONMENT=production,GOOGLE_CLOUD_PROJECT=project-id,GOOGLE_CLOUD_LOCATION=us-central1,GOOGLE_GENAI_USE_VERTEXAI=true"
```

**5. Deployment Debug Commands**
```bash
# Check service status
./deployment/deploy.sh status

# View deployment logs
./deployment/deploy.sh logs

# Test health endpoint
curl "$(./deployment/quick-deploy.sh url)/health"

# Check environment variables
gcloud run services describe SERVICE_NAME --region us-central1 --format="yaml" | grep -A 20 "env:"
```

When writing code, always reference these ADK integration patterns. The key insight is that ADK provides the agent backend while your FastAPI app provides the custom authentication and user interface layer. **Always verify Google Cloud setup before troubleshooting code issues.**

**For deployment issues, check `deployment/README.md` for comprehensive troubleshooting guide.**