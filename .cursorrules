# Job Matching App - Cursor AI Rules

## Project Context
Building a job matching MVP where Talent and Companies chat with AI agents. FastAPI application with custom authentication and UI, powered by Google ADK for agent functionality.

## Required Tech Stack (DO NOT SUGGEST ALTERNATIVES)
- Python with UV dependency management
- FastAPI backend with Jinja2 templates
- HTMX for dynamic frontend interactions
- Google ADK for agent orchestration and LLM backend
- Vertex AI (Gemini) via ADK
- Firebase Authentication
- Firestore for all data storage
- Cloud Run for deployment
- Google Cloud Storage via ADK Artifacts for files

## Architecture Constraints
- Main FastAPI app with ADK mounted as sub-application
- No microservices, no complex session management
- Use Firestore for everything (no SQLite, no other databases)
- ADK Artifacts for file handling (no custom upload logic)
- Environment-based configuration only
- Jinja2 templates for HTML rendering
- HTMX for dynamic interactions (no complex JavaScript)
- Component-based template architecture with shared components

## Project Structure
```
laiers/
â”œâ”€â”€ main.py                 # Main FastAPI app with ADK integration
â”œâ”€â”€ job_matching_agent/     # ADK agent directory (REQUIRED structure)
â”‚   â”œâ”€â”€ __init__.py        # Must contain: from . import agent
â”‚   â”œâ”€â”€ agent.py           # Must contain: root_agent = Agent(...)
â”‚   â”œâ”€â”€ job_posting_agent.py    # Sub-agent for job creation
â”‚   â””â”€â”€ assessment_agent.py     # Sub-agent for candidate evaluation
â”œâ”€â”€ pyproject.toml         # UV project configuration & dependencies
â”œâ”€â”€ uv.lock               # UV lockfile (auto-generated)
â”œâ”€â”€ .env                   # Environment variables (local dev)
â”œâ”€â”€ .env.example          # Template for environment variables
â”œâ”€â”€ .gitignore            # Git ignore file
â”œâ”€â”€ README.md             # Project documentation
â”œâ”€â”€ templates/            # Jinja2 template files
â”‚   â”œâ”€â”€ base.html         # Base template with common elements
â”‚   â”œâ”€â”€ landing.html      # Landing page with branding
â”‚   â”œâ”€â”€ login.html        # Login page
â”‚   â”œâ”€â”€ register.html     # Registration page
â”‚   â”œâ”€â”€ dashboard.html    # Multi-section dashboard with profile + chat
â”‚   â”œâ”€â”€ company.html      # Company portal with opportunities list
â”‚   â”œâ”€â”€ opportunities_list.html  # Card-based opportunity browsing
â”‚   â”œâ”€â”€ create_opportunity.html  # AI-guided opportunity creation
â”‚   â”œâ”€â”€ opportunity_detail.html  # Job details + application form + assessment
â”‚   â””â”€â”€ components/       # Reusable template components
â”‚       â”œâ”€â”€ header.html           # Shared header component
â”‚       â”œâ”€â”€ chat_message.html     # Chat message component
â”‚       â”œâ”€â”€ chat_error.html       # Chat error component
â”‚       â”œâ”€â”€ opportunity_card.html # Opportunity display card
â”‚       â”œâ”€â”€ survey_form.html      # Application survey form
â”‚       â”œâ”€â”€ chat.html            # Chat interface component
â”‚       â”œâ”€â”€ forms.html           # Form components
â”‚       â””â”€â”€ messages.html        # Message display components
â”œâ”€â”€ static/               # Static assets
â”‚   â”œâ”€â”€ css/
â”‚   â”‚   â”œâ”€â”€ styles.css    # Main stylesheet
â”‚   â”‚   â”œâ”€â”€ opportunities.css     # Opportunity browsing styles
â”‚   â”‚   â”œâ”€â”€ company.css          # Company portal styles
â”‚   â”‚   â”œâ”€â”€ create-opportunity.css # Opportunity creation styles
â”‚   â”‚   â””â”€â”€ opportunity-detail.css # Job detail + assessment styles
â”‚   â””â”€â”€ images/           # Static images
â”‚       â”œâ”€â”€ logo_laiers.png      # Main Laiers.ai logo
â”‚       â””â”€â”€ favicon.ico          # Site favicon
â”œâ”€â”€ config/
â”‚   â”œâ”€â”€ firebase-credentials.json     # Firebase service account key
â”‚   â””â”€â”€ firebase-web-config.json      # Firebase web app config
â”œâ”€â”€ utils/                # Utility modules (keep minimal)
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ firestore.py      # Firestore helpers + opportunity management
â”‚   â”œâ”€â”€ auth.py           # Firebase authentication helpers
â”‚   â”œâ”€â”€ middleware.py     # Maintenance mode middleware
â”‚   â””â”€â”€ model.py          # Pydantic models (renamed from models.py)
â”œâ”€â”€ deployment/           # Cloud Run deployment system
â”‚   â”œâ”€â”€ deploy.sh         # Full-featured deployment script
â”‚   â”œâ”€â”€ quick-deploy.sh   # Quick deployment commands
â”‚   â”œâ”€â”€ README.md         # Comprehensive deployment guide
â”‚   â””â”€â”€ cloudbuild.yaml  # Cloud Build configuration
â”œâ”€â”€ Dockerfile            # Container configuration for Cloud Run (uses UV)
â”œâ”€â”€ .dockerignore        # Files excluded from container build
â””â”€â”€ run.py               # Entry point for Cloud Run deployment
```

## Code Patterns to Follow

### ADK + FastAPI Integration Pattern
```python
import os
from fastapi import FastAPI, Request, Depends
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates
from fastapi.responses import HTMLResponse, RedirectResponse
from google.adk.cli.fast_api import get_fast_api_app

# Create main FastAPI app for custom routes
app = FastAPI(title="Job Matching App")

# Initialize templates and static files
templates = Jinja2Templates(directory="templates")
app.mount("/static", StaticFiles(directory="static"), name="static")

# Get ADK app and mount it under /adk path
AGENT_DIR = os.path.dirname(os.path.abspath(__file__))
adk_app = get_fast_api_app(
    agents_dir=AGENT_DIR,
    allow_origins=["*"] if ENVIRONMENT == "development" else [],
    web=True,  # Enables dev UI at /adk/dev-ui/
)

# Mount ADK app under /adk prefix
app.mount("/adk", adk_app)

# Your custom routes
@app.get("/", response_class=HTMLResponse)
async def landing_page(request: Request, user = Depends(optional_auth)):
    """Landing page - redirect to dashboard if logged in"""
    if user:
        return RedirectResponse(url="/dashboard", status_code=302)
    return templates.TemplateResponse("landing.html", {"request": request})

@app.get("/dashboard", response_class=HTMLResponse)
async def dashboard(request: Request, user = Depends(require_auth)):
    """Dashboard with profile + chat interface"""
    user_profile = await firestore_service.get_user_profile(user['uid'])
    return templates.TemplateResponse("dashboard.html", {
        "request": request,
        "user": user,
        "user_profile": user_profile
    })

@app.post("/api/chat")
async def chat_with_agent(
    request: Request,
    message: str = Form(...),
    user = Depends(require_auth)
):
    """Chat with ADK agent via HTMX"""
    # Use ADK's HTTP API internally
    payload = {
        "appName": "job_matching_agent",
        "userId": user["uid"],
        "sessionId": f"session_{user['uid']}",
        "newMessage": {"role": "user", "parts": [{"text": message}]},
        "streaming": False
    }
    
    async with httpx.AsyncClient() as client:
        response = await client.post("http://localhost:8000/adk/run", json=payload)
        agent_response = response.json()
    
    # Return HTMX partial
    return templates.TemplateResponse("components/chat_message.html", {
        "request": request,
        "user_message": message,
        "agent_response": agent_response[0]["content"]["parts"][0]["text"],
        "timestamp": datetime.now()
    })
```

### ADK Agent Structure (REQUIRED) - UPDATED WITH SUB-AGENTS
```python
# job_matching_agent/__init__.py
from . import agent

# job_matching_agent/agent.py
from google.adk.agents import LlmAgent
from google.adk.tools.agent_tool import AgentTool
from .job_posting_agent import job_posting_agent
from .assessment_agent import assessment_agent

# This MUST be named 'root_agent' for ADK discovery
root_agent = LlmAgent(
    name="job_matching_agent",
    model="gemini-2.0-flash-lite",
    instruction="""You are a job matching assistant for a professional platform.

Context: You will receive user information including their user_type ('talent' or 'company') and potentially a task type.

For 'talent' users:
- Help with resume review and optimization
- Provide job search strategies and tips
- Offer interview preparation guidance
- Suggest skill development opportunities
- Answer career-related questions

For 'company' users:
- Assist with writing effective job descriptions
- Provide candidate screening and evaluation guidance
- Offer hiring best practices and strategies
- Help with employer branding advice
- Support recruitment process optimization

For 'company' users with Task: 'create_opportunity':
IMMEDIATELY use the job_posting_agent tool. Do not create job opportunities yourself - always delegate this task to the job_posting_agent tool which specializes in the complete workflow including soft skills identification and behavioral interview question creation.

For 'company' users with Task: 'assess_candidates':
IMMEDIATELY use the assessment_agent tool. Do not attempt to evaluate candidates yourself - always delegate this task to the assessment_agent tool which specializes in analyzing survey responses, ranking candidates, and providing evaluation insights.

Use the get_user_context tool to understand who you're talking to and the analyze_user_needs tool to provide appropriate guidance.

Always maintain a professional, helpful, and encouraging tone. Ask follow-up questions to better understand their specific needs and provide personalized advice.""",
    tools=[
        AgentTool(agent=job_posting_agent),
        AgentTool(agent=assessment_agent),
        # ... other tools
    ]
)

# job_matching_agent/job_posting_agent.py
from google.adk.agents import LlmAgent

job_posting_agent = LlmAgent(
    name="job_posting_agent",
    model="gemini-2.0-flash-lite",
    instruction="""You are a specialized job posting creation assistant..."""
)

# job_matching_agent/assessment_agent.py  
from google.adk.agents import LlmAgent

assessment_agent = LlmAgent(
    name="assessment_agent",
    model="gemini-2.0-flash-lite", 
    instruction="""You are a candidate assessment specialist that helps company users evaluate job applicants.

Your expertise includes:
- Analyzing candidate survey responses against job requirements
- Identifying top candidates based on qualifications and responses
- Suggesting interview questions tailored to each candidate
- Providing objective evaluation criteria and scoring
- Highlighting potential red flags or standout qualities

When evaluating candidates:
1. Review the job requirements and description carefully
2. Analyze each candidate's survey responses for relevance and quality
3. Look for specific examples, quantifiable achievements, and relevant experience
4. Consider communication skills, attention to detail, and cultural fit indicators
5. Provide balanced assessments highlighting both strengths and areas of concern

Always maintain objectivity and focus on job-relevant criteria. Provide constructive insights that help hiring managers make informed decisions while avoiding bias."""
)
```

### Assessment Feature Pattern - NEW
```python
# Opportunity Detail Route with Assessment
@app.get("/opportunities/{opportunity_id}", response_class=HTMLResponse)
async def opportunity_detail(request: Request, opportunity_id: str, user = Depends(require_auth)):
    """Opportunity detail page with application form for talent users and assessment for company users"""
    # Get opportunity
    opportunity = await firestore_service.get_opportunity(opportunity_id)
    if not opportunity:
        raise HTTPException(status_code=404, detail="Opportunity not found")
    
    # Get user profile
    user_profile = await firestore_service.get_user_profile(user['uid'])
    if not user_profile:
        raise HTTPException(status_code=404, detail="User profile not found")
    
    # Check if user has already applied (for talent users)
    has_applied = False
    if user_profile.get('user_type') == 'talent':
        has_applied = await firestore_service.check_existing_application(opportunity_id, user['uid'])
    
    # Get applications count for company users who own this opportunity
    applications_count = 0
    if user_profile.get('user_type') == 'company' and user_profile.get('company_id') == opportunity.get('company_id'):
        applications = await firestore_service.get_applications_by_opportunity(opportunity_id)
        applications_count = len(applications)
    
    return templates.TemplateResponse("opportunity_detail.html", {
        "request": request,
        "user": user,
        "user_profile": user_profile,
        "opportunity": opportunity,
        "has_applied": has_applied,
        "applications_count": applications_count,
        "firebase_config": web_config
    })

# Assessment API Endpoint
@app.post("/api/opportunities/{opportunity_id}/assess")
async def assess_candidates(
    request: Request,
    opportunity_id: str,
    message: str = Form(...),
    user = Depends(require_auth)
):
    """Chat with assessment agent for candidate evaluation via HTMX"""
    try:
        user_profile = await firestore_service.get_user_profile(user['uid'])
        if not user_profile:
            raise HTTPException(status_code=400, detail="User profile not found")
        
        # Get opportunity and verify ownership
        opportunity = await firestore_service.get_opportunity(opportunity_id)
        if not opportunity:
            raise HTTPException(status_code=404, detail="Opportunity not found")
        
        # Verify user has access to assess candidates for this opportunity
        if user_profile.get('user_type') != 'company' or user_profile.get('company_id') != opportunity.get('company_id'):
            raise HTTPException(status_code=403, detail="Access denied")
        
        # Get applications for this opportunity
        applications = await firestore_service.get_applications_by_opportunity(opportunity_id)
        
        # Prepare rich context for assessment agent
        assessment_request = f"""Assess candidates for this position:

**Job Opportunity:** {opportunity.get('title')}
**Company:** {company_name}
**Description:** {opportunity.get('description')}
**Requirements:** {opportunity.get('requirements', 'No specific requirements listed')}

**Survey Questions:**
{chr(10).join([f"{i+1}. {q.get('question', '')}" for i, q in enumerate(opportunity.get('survey_questions', []))])}

**Candidates to Evaluate:** {len(applications)} applicant(s)
{chr(10).join([f"- {app['applicant_name']} ({app['applicant_email']})" for app in applications])}

**User Request:** {message}

Please provide a comprehensive assessment including candidate ranking, strengths/weaknesses, and interview recommendations."""

        contextual_message = f"[User type: company, Task: assess_candidates, Opportunity ID: {opportunity_id}] {assessment_request}"
        
        # Send to ADK agent with proper timeout
        async with httpx.AsyncClient(timeout=30.0) as client:
            # ... ADK communication logic
            
        return templates.TemplateResponse("components/chat_message.html", {
            "request": request,
            "user_message": message,
            "agent_response": final_response,
            "timestamp": datetime.now()
        })
        
    except Exception as e:
        logger.error(f"Assessment chat error: {e}")
        return templates.TemplateResponse("components/chat_error.html", {
            "request": request,
            "error": "Failed to process assessment message. Please try again."
        })
```

### Assessment UI Template Pattern - NEW
```html
<!-- Assessment Interface in opportunity_detail.html -->
{% if user_profile.user_type == 'company' and user_profile.company_id == opportunity.company_id %}
<div class="assessment-section">
    <div class="assessment-header">
        <h2 class="assessment-title">ðŸŽ¯ Candidate Assessment</h2>
        <div class="assessment-stats">
            <span class="stat-item">
                <strong>{{ applications_count }}</strong> 
                candidate{{ 's' if applications_count != 1 else '' }} applied
            </span>
        </div>
    </div>
    
    <div class="assessment-chat-container">
        <div id="assessment-chat-messages" class="assessment-chat-messages">
            <div class="welcome-message">
                <p><strong>ðŸ‘‹ Hi! I'm your AI candidate assessment assistant.</strong></p>
                <p>I can help you <strong>evaluate applicants</strong>, <strong>rank candidates</strong>, and <strong>suggest interview questions</strong> based on their survey responses and job requirements.</p>
                {% if applications_count and applications_count > 0 %}
                <p><strong>{{ applications_count }} candidate{{ 's' if applications_count != 1 else '' }}</strong> ha{{ 've' if applications_count != 1 else 's' }} applied to this position. How would you like to assess them?</p>
                {% else %}
                <p>No applications yet, but you can still prepare assessment criteria and interview questions for when candidates apply.</p>
                {% endif %}
            </div>
        </div>
        
        <form class="assessment-chat-form" 
              hx-post="/api/opportunities/{{ opportunity.id }}/assess" 
              hx-target="#assessment-chat-messages" 
              hx-swap="beforeend"
              hx-trigger="submit" 
              hx-indicator=".assessment-loading-indicator">
            <input type="text" 
                   name="message" 
                   class="assessment-chat-input"
                   placeholder="Ask me to evaluate candidates, rank applicants, or suggest interview questions..." 
                   required 
                   autocomplete="off">
            <button type="submit">
                Assess
                <span class="htmx-indicator assessment-loading-indicator"> ...</span>
            </button>
        </form>
    </div>
</div>
{% endif %}
```

### Assessment Agent Tool Pattern - NEW
```python
# job_matching_agent/assessment_agent.py
from google.adk.agents import LlmAgent
from typing import List, Dict, Any

def analyze_candidate_fit(opportunity_data: Dict[str, Any], application: Dict[str, Any]) -> Dict[str, Any]:
    """Analyze how well a candidate fits an opportunity based on their survey responses"""
    
    survey_responses = application.get('survey_responses', {})
    opportunity_requirements = opportunity_data.get('requirements', '')
    opportunity_description = opportunity_data.get('description', '')
    
    # Extract survey questions and responses for analysis
    survey_analysis = []
    survey_questions = opportunity_data.get('survey_questions', [])
    
    for i, question in enumerate(survey_questions):
        # Handle both string and dictionary formats for survey questions
        if isinstance(question, dict):
            # Dictionary format: {"question": "text", "type": "text", "required": True}
            question_text = question.get('question', f'Question {i+1}')
            question_type = question.get('type', 'text')
        else:
            # String format: "question text"
            question_text = str(question)
            question_type = 'text'
        
        question_key = f"question_{i}"
        response = survey_responses.get(question_key, "No response provided")
        
        survey_analysis.append({
            "question": question_text,
            "type": question_type,
            "response": response,
            "response_quality": "poor" if not response or response.lower().strip() in ["", "n/a", "none", "i don't know", "i can't remember"] else "good"
        })
    
    # Analyze overall candidate fit
    total_questions = len(survey_analysis)
    good_responses = sum(1 for q in survey_analysis if q["response_quality"] == "good")
    response_rate = (good_responses / total_questions) if total_questions > 0 else 0
    
    # Determine fit level
    if response_rate >= 0.8:
        fit_level = "excellent"
    elif response_rate >= 0.6:
        fit_level = "good"
    elif response_rate >= 0.4:
        fit_level = "fair"
    else:
        fit_level = "poor"
    
    return {
        "candidate_id": application.get('candidate_id', 'unknown'),
        "fit_level": fit_level,
        "response_rate": response_rate,
        "survey_analysis": survey_analysis,
        "requirements_match": opportunity_requirements,
        "job_description": opportunity_description,
        "total_questions": total_questions,
        "good_responses": good_responses
    }

assessment_agent = LlmAgent(
    name="assessment_agent",
    model="gemini-2.0-flash-lite",
    instruction="""You are a candidate assessment specialist...""",
    tools=[
        FunctionTool(analyze_candidate_fit),
        FunctionTool(rank_candidates),
        FunctionTool(generate_interview_questions)
    ]
)
```

## Development URLs and Endpoints

### Main Application URLs
- **Landing Page**: `http://localhost:8000/`
- **Registration**: `http://localhost:8000/register?user_type=talent|company`
- **Login**: `http://localhost:8000/login`
- **Dashboard**: `http://localhost:8000/dashboard` (requires auth)

### Opportunity Management URLs - UPDATED WITH ASSESSMENT
- **Company Portal**: `http://localhost:8000/company/{company_id}` - Company page with opportunities list
- **Create Opportunity**: `http://localhost:8000/company/{company_id}/opportunities/create` - AI-guided creation
- **Browse Opportunities**: `http://localhost:8000/opportunities` - All opportunities (talent users)
- **Opportunity Details**: `http://localhost:8000/opportunities/{opportunity_id}` - Job details + application + assessment
- **Apply to Opportunity**: `POST /api/opportunities/{opportunity_id}/apply` - Submit application
- **Create Opportunity API**: `POST /api/opportunities/create` - HTMX chat during creation
- **Assess Candidates API**: `POST /api/opportunities/{opportunity_id}/assess` - HTMX assessment chat

### ADK Integration URLs - VERIFIED WORKING
- **ADK Dev UI**: `http://localhost:8000/adk/dev-ui/` (note trailing slash!)
- **ADK API Docs**: `http://localhost:8000/adk/docs`
- **Agent Test**: `http://localhost:8000/test/adk-complete-flow` (custom test endpoint)

### Debug URLs
- **Debug Agent**: `http://localhost:8000/debug/adk`
- **Health Check**: `http://localhost:8000/health`
- **Test Opportunities**: `http://localhost:8000/test/opportunities/{company_id}` - Debug opportunities

## Coding Rules

### What to ALWAYS do:
- **ADK Integration**: Mount ADK app under `/adk` prefix, never replace main app
- **Agent Structure**: Use required `job_matching_agent/` directory with `root_agent` variable
- **Sub-Agent Architecture**: Use AgentTool to integrate job_posting_agent and assessment_agent
- **Template Organization**: Two-panel dashboard (profile + chat), component-based HTMX responses
- **Assessment Feature**: Include assessment interface on opportunity detail pages for company users
- **Firebase Auth**: Use session cookies, not JWT tokens in requests
- **Context Passing**: Always pass user context to ADK agent (user_type, task, etc.)
- **Error Handling**: Use try/except blocks with proper logging
- **HTMX Patterns**: Form-based chat interface, partial template responses
- **Environment Config**: Load all config from environment variables with proper validation
- **Google Cloud Setup**: Always verify Vertex AI API is enabled before deployment
- **ADK Communication**: Use HTTP client to call ADK endpoints internally, not direct imports
- **Data Format Handling**: Make assessment tools robust to handle both string and dict formats

### Template Patterns:
- **Dashboard**: Two-panel grid layout (profile left, chat right)
- **Chat Interface**: HTMX form with `hx-post="/api/chat"` targeting messages container
- **Assessment Interface**: Specialized chat for candidate evaluation on opportunity detail pages
- **HTMX Responses**: Return `components/chat_message.html` for new messages
- **Mobile Responsive**: Grid collapses to single column on mobile
- **User Context**: Show different chat welcome based on user_type
- **Conditional Features**: Show assessment interface only to company users who own the opportunity

### ADK-Specific Rules - UPDATED BASED ON TESTING:
- **Agent Discovery**: ADK looks for `root_agent` variable in agent directory
- **Sub-Agent Integration**: Use AgentTool to mount sub-agents as tools
- **Mounting**: Mount ADK app under path, don't replace main FastAPI app
- **Dev UI**: Always accessible at `/adk/dev-ui/` (with trailing slash)
- **Agent Communication**: Use HTTP calls to `/adk/run` endpoint, not direct Runner imports
- **Environment Variables**: Must have `GOOGLE_CLOUD_PROJECT` and `GOOGLE_CLOUD_LOCATION`
- **API Dependencies**: Vertex AI API must be enabled in Google Cloud Console
- **Authentication**: Use Application Default Credentials (gcloud auth application-default login)
- **Timeout Handling**: Use 30-second timeouts for complex agent operations like assessment

### What to NEVER suggest:
- **Replacing ADK patterns**: Don't suggest alternatives to ADK's agent structure
- **Complex JavaScript**: Keep HTMX-only, minimal custom JS
- **Alternative auth**: Firebase only, no custom JWT handling
- **Database alternatives**: Firestore only, no SQLite/PostgreSQL
- **Microservices**: Single application with mounted sub-apps only
- **Different agent frameworks**: ADK only, no LangChain/CrewAI alternatives
- **Direct ADK imports**: Use HTTP API calls, not direct Python imports of ADK classes
- **Assessment without sub-agents**: Always use assessment_agent for candidate evaluation

### Error Handling Pattern - UPDATED:
```python
try:
    # ADK agent interaction via HTTP with proper timeout
    payload = {
        "appName": "job_matching_agent",
        "userId": user["uid"],
        "sessionId": f"session_{user['uid']}",
        "newMessage": {"role": "user", "parts": [{"text": message}]},
        "streaming": False
    }
    
    async with httpx.AsyncClient(timeout=30.0) as client:  # Extended timeout for assessment
        response = await client.post("http://localhost:8000/adk/run", json=payload)
        if response.status_code == 200:
            agent_data = response.json()
            agent_response = agent_data[0]["content"]["parts"][0]["text"]
        else:
            raise Exception(f"ADK API error: {response.status_code}")
    
    return templates.TemplateResponse("components/chat_message.html", {
        "request": request,
        "user_message": message,
        "agent_response": agent_response,
        "timestamp": datetime.now()
    })
except Exception as e:
    logger.error(f"Chat error: {e}")
    return templates.TemplateResponse("components/chat_error.html", {
        "request": request,
        "error": "Failed to process message"
    })
```

## Development Focus - UPDATED
- **Professional Product**: Focus on polished user experience with consistent branding
- **User Types**: "company" and "talent" with sophisticated user flows
- **Context-Aware Agent**: Agent adapts responses based on user_type and context
- **Sub-Agent Architecture**: Specialized agents for job posting and candidate assessment
- **Component-Based UI**: Reusable templates and consistent design patterns
- **Card-Based Browsing**: Modern interface for opportunity discovery
- **Assessment Features**: Comprehensive candidate evaluation tools for company users
- **Responsive Design**: Mobile-friendly multi-section layouts
- **Opportunity Management**: Complete job posting and application workflow with rich metadata
- **AI-Guided Creation**: Use ADK agent for structured opportunity creation
- **AI-Powered Assessment**: Use specialized assessment agent for candidate evaluation
- **HTMX Interactions**: Dynamic forms with loading states and auto-scroll
- **Firestore Integration**: All data stored in Firestore collections
- **Production Ready**: Complete Cloud Run deployment with maintenance mode

## Common Mistakes to Avoid - UPDATED
- **Wrong ADK mounting**: Don't use ADK app as main app, mount under `/adk`
- **Missing trailing slash**: ADK dev UI needs `/adk/dev-ui/` not `/adk/dev-ui`
- **Agent structure**: Must have `job_matching_agent/` directory with `root_agent`
- **Missing sub-agents**: Include job_posting_agent and assessment_agent as tools
- **Template context**: Always pass `request` object to template responses
- **User context**: Don't forget to pass user_type to agent for personalization
- **Assessment access**: Only show assessment interface to company users who own the opportunity
- **Data format assumptions**: Make assessment tools handle both string and dict formats
- **HTMX targets**: Use correct selectors for message container updates
- **Environment variables**: Use `GOOGLE_CLOUD_LOCATION` not `VERTEX_AI_LOCATION`
- **API not enabled**: Always check Vertex AI API is enabled in Google Cloud Console
- **Authentication**: Must run `gcloud auth application-default login`
- **Direct imports**: Don't import ADK classes directly, use HTTP API
- **Timeout issues**: Use 30-second timeouts for complex operations like assessment
- **Branding inconsistency**: Always use established logo sizing and color schemes
- **Component duplication**: Use shared components instead of duplicating header/footer code
- **Missing loading states**: Always provide visual feedback for HTMX requests
- **Broken responsive design**: Test grid layouts collapse properly on mobile

## Troubleshooting - CRITICAL ISSUES

### Assessment Feature Issues - NEW

**Assessment Agent Not Working:**
1. **Check Sub-Agent Structure**: Ensure `assessment_agent.py` exists with proper tools
2. **Verify AgentTool Integration**: Confirm assessment_agent is mounted as tool in root_agent
3. **Data Format Issues**: Check if survey questions are strings vs dictionaries
4. **Timeout Problems**: Increase timeout to 30 seconds for complex assessments
5. **Access Control**: Verify company user owns the opportunity being assessed

**Assessment UI Not Showing:**
1. **Template Conditional**: Check user_type == 'company' and company_id matches
2. **Applications Count**: Verify applications are being retrieved from Firestore
3. **CSS Loading**: Ensure opportunity-detail.css includes assessment styles
4. **HTMX Endpoint**: Confirm `/api/opportunities/{id}/assess` endpoint exists

**Assessment Data Errors:**
```python
# Common fix for survey question format issues
for i, question in enumerate(survey_questions):
    # Handle both string and dictionary formats
    if isinstance(question, dict):
        question_text = question.get('question', f'Question {i+1}')
    else:
        question_text = str(question)  # Convert string format
```

### ADK Agent Not Working (500 Error)
1. **Check Vertex AI API**: Visit `https://console.developers.google.com/apis/api/aiplatform.googleapis.com/overview?project=YOUR_PROJECT_ID`
2. **Verify Authentication**: Run `gcloud auth application-default login`
3. **Check Environment**: Ensure `GOOGLE_CLOUD_PROJECT` and `GOOGLE_CLOUD_LOCATION` are set
4. **Test Connection**: Use `/test/adk-complete-flow` endpoint to verify setup

### Session Already Exists (400 Error)
This is NORMAL behavior. ADK reuses existing sessions. Only worry if message sending fails.

### 403 Permission Denied
- Enable Vertex AI API in Google Cloud Console
- Wait 2-3 minutes after enabling
- Verify project ID matches in environment variables

When writing code, always reference these ADK integration patterns with sub-agent architecture. The key insight is that ADK provides the agent backend while your FastAPI app provides the custom authentication and user interface layer. **Always verify Google Cloud setup before troubleshooting code issues.**

**For assessment features, ensure proper sub-agent integration and data format handling.**